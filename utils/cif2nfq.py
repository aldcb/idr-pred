#!/usr/bin/env python3
# Copyright (c) 2024 aldcb - GPLv3 (http://gnu.org/licenses/gpl.html)

import argparse
import os

def cif_to_nfq_entry(file_path, check_alphafold = True):
    """Reads a single CIF file and returns a NFQ (Not FastQ) entry.
    Arguments:
        input_path (str): path to the input CIF file.
        check_alphafold (bool, default True): verify expected file structure, generated by AlphaFold.
    Returns:
        str: FASTQ-like entry with differing headers and two score bytes per residue.
    """
    with open(file_path, "r") as file:
        lines = file.readlines()
        for line in lines:
            if not line.startswith("_"):
                continue
            match line.split()[0].strip("\n"):
                case "_citation.title":
                    try:
                        if line.split("\"")[1].split("\"")[0] != "Highly accurate protein structure prediction with AlphaFold":
                            break
                        is_alphafold = True
                    except IndexError:
                        break
                case "_entry.id":
                    af_id = line.split()[1]
                case "_ma_target_ref_db_details.organism_scientific":
                    org = " ".join(line.split()[1:3]).strip("\"")
                case "_entity.pdbx_description":
                    try:
                        name = line.split("\"")[1].split("\"")[0]
                    except IndexError:
                        name = line.split()[1]
                case "_entity_poly.pdbx_seq_one_letter_code":
                    try:
                        sequence = line.split()[1]
                    except IndexError:
                        sequence = ""
                        for inner_line in lines[lines.index(line) + 1:]:
                            if inner_line == ";\n":
                                break
                            sequence += inner_line.replace(";", "").strip("\n")
                case "_ma_qa_metric_local.ordinal_id":
                    af_score = ""
                    for inner_line in lines[lines.index(line) + 1:]:
                        if inner_line == "#\n":
                            break
                        plddt_split = inner_line.split()[4].split(".")
                        af_score += chr(27+int(plddt_split[0])) + chr(27+int(plddt_split[1]))
        if check_alphafold and not "is_alphafold" in locals():
            raise ValueError(f"{file_path} might be structured differently than expected.")
    return f"@{name} [{org}]\n{sequence}\n+{af_id}\n{af_score}\n"

def get_cifs(input_path):
    """Get list of CIF file paths and raise exceptions if needed."""
    if not os.path.exists(input_path):
        raise FileNotFoundError(f"Input path {input_path} doesn't exist.")
    if os.path.isfile(input_path):
        if not input_path.lower().endswith(".cif"):
            raise FileNotFoundError(f"Input file {input_path} has unexpected extension")
        return [input_path]
    files = [f for f in os.listdir(input_path) if f.lower().endswith(".cif")]
    if not files:
        raise FileNotFoundError(f"No CIF files found in {input_path}.")
    return [os.path.join(input_path, file_name) for file_name in files]

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("input_path", help="Path to the input CIF file or folder.")
    parser.add_argument("output_path", help="Path to the output NFQ (FASTQ-like) file.")
    args = parser.parse_args()
    if not args.output_path.lower().endswith(".nfq"):
        raise ValueError(f"Output file must have NFQ extension")
    with open(args.output_path, "w") as nfq:
        print(get_cifs(args.input_path))
        for cif in get_cifs(args.input_path):
            entry = cif_to_nfq_entry(cif)
            nfq.write(entry)
